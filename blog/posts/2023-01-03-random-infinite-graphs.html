<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Mark Girard">
<meta name="dcterms.date" content="2023-01-03">
<meta name="description" content="A deep dive into universality of infinite random graphs.">

<title>Mark W. Girard - Random Infinite Graphs</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Mark W. Girard</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html" rel="" target="">
 <span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../academic/academic.html" rel="" target="">
 <span class="menu-text">Academic</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../riddlers.html" rel="" target="">
 <span class="menu-text">Puzzles</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../blog/index.html" rel="" target="">
 <span class="menu-text">Blog</span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools ms-auto">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#background" id="toc-background" class="nav-link active" data-scroll-target="#background">Background</a></li>
  <li><a href="#infinite-graphs-and-universality" id="toc-infinite-graphs-and-universality" class="nav-link" data-scroll-target="#infinite-graphs-and-universality">Infinite graphs and universality</a></li>
  <li><a href="#random-infinite-graphs-are-almost-always-the-same" id="toc-random-infinite-graphs-are-almost-always-the-same" class="nav-link" data-scroll-target="#random-infinite-graphs-are-almost-always-the-same">Random infinite graphs are almost always the same</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Random Infinite Graphs</h1>
  <div class="quarto-categories">
    <div class="quarto-category">mathematics</div>
    <div class="quarto-category">combinitorics</div>
  </div>
  </div>

<div>
  <div class="description">
    A deep dive into universality of infinite random graphs.
  </div>
</div>


<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Mark Girard </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">January 3, 2023</p>
    </div>
  </div>
  
    
  </div>
  

</header>

<p>I picked up a book at a used book store recently: <em><a href="https://www.amazon.ca/Probabilistic-Methods-Combinatorics-Paul-Erdos/dp/0122409604">Probabilistic Methods in Combinitorics</a></em> (1974) by Paul Erdős and Joel Spencer. Always a sucker for neat-looking old math books, I picked it up and browse through it ocassionally.</p>
<p>As with most of Erdős’ writing, I found the statements and proofs in the book rather obtuse. To help me understand some of the contents, I wanted to write some blog posts as I read through it.</p>
<p>The first topic I wanted to look at was a simple one: random infinite graphs. Here, Spencer and Erdős consider randomly generated graphs whose sets of vertices are the natural numbers. Something interesting happens with the graphs generated this way. Namely, they are almost always the same! Up to isomorphism, at least.</p>
<section id="background" class="level2">
<h2 class="anchored" data-anchor-id="background">Background</h2>
<p>Recall that a <em>graph</em> <span class="math inline">\(G\)</span> is an ordered pair <span class="math inline">\((V,E)\)</span> consisting of a set <span class="math inline">\(V\)</span> of vertices and a set of edges</p>
<p><span class="math display">\[
E\subseteq\binom{V}{2}
\]</span></p>
<p>(where we recall that given a set <span class="math inline">\(S\)</span> and an integer <span class="math inline">\(k\)</span>, the notation <span class="math inline">\(\binom{S}{k}\)</span> is used to denote the collection of all subsets of <span class="math inline">\(S\)</span> containing exactly <span class="math inline">\(k\)</span> elements). We may write <span class="math inline">\(\operatorname{Vertices}(G)=V\)</span> and <span class="math inline">\(\operatorname{Edges}(G)=E\)</span>. Two distinct vertices <span class="math inline">\(a,b\in \operatorname{Vertices}(G)\)</span> are said to be <em>adjacent</em> in <span class="math inline">\(G\)</span> if it holds that</p>
<p><span class="math display">\[
\lbrace a,b\rbrace \in \operatorname{Edges}(G)
\]</span></p>
<p>and not adjacent otherwise.</p>
<p>Two graphs <span class="math inline">\(G\)</span> and <span class="math inline">\(H\)</span> are said to be <em>isomorphic</em> if there exists a bijection</p>
<p><span class="math display">\[
f:\operatorname{Vertices}(G)\to\operatorname{Vertices}(H)
\]</span></p>
<p>with the property that, for every choice of distinct pairs of vertices <span class="math inline">\(a,b\in\operatorname{Vertices}(G)\)</span>, we have the equivalence</p>
<p><span class="math display">\[
\lbrace a,b\rbrace \in \operatorname{Edges}(G)\iff\lbrace f(a),f(b)\rbrace \in \operatorname{Edges}(H).
\]</span></p>
<p>Graph isomorphism defines an equivalence relation on a collection of graphs.</p>
</section>
<section id="infinite-graphs-and-universality" class="level2">
<h2 class="anchored" data-anchor-id="infinite-graphs-and-universality">Infinite graphs and universality</h2>
<p>The set of vertices in a graph is usually taken to be finite, but there is no reason we can’t consider graphs to have infinite sets of vertices. In this note in particular, we will consider graphs whose sets of vertices are the natural numbers <span class="math inline">\(\mathbb{N}\)</span>.</p>
<blockquote class="blockquote">
<p><strong>Definition.</strong> A graph <span class="math inline">\(G\)</span> with <span class="math inline">\(\operatorname{Vertices}(G)=\mathbb{N}\)</span> is said to be <em>universal</em> if, for every pair of finite disjoint subsets <span class="math inline">\(S,T\subseteq\mathbb{N}\)</span> there exists a choice of vertex <span class="math inline">\(a\in\mathbb{N}\setminus(S\cup T)\)</span> that is adjacent to every vertex in <span class="math inline">\(S\)</span> and not adjacent to every vertex in <span class="math inline">\(T\)</span>.</p>
</blockquote>
<p>Symbolically, a graph <span class="math inline">\(G\)</span> is universal if the following statement holds:</p>
<p><span class="math display">\[
\forall n,k\in \mathbb{N},\,\forall S\in\binom{\mathbb{N}}{n},\,\forall T\in\binom{\mathbb{N}\setminus S}{k},\, \exists a\in \mathbb{N}\setminus(S\cup T), \,\forall s\in S\cup T, \bigg(s\in S \iff \lbrace a,s\rbrace \in\operatorname{Edges}(G)\bigg)
\]</span></p>
<p>Fascinatingly, it turns out that all universal graphs are isomorphic!</p>
<blockquote class="blockquote">
<p><strong>Proposition.</strong> All universal graphs on <span class="math inline">\(\mathbb{N}\)</span> are isomorphic.</p>
</blockquote>
<p><em>Proof.</em> Suppose <span class="math inline">\(G\)</span> and <span class="math inline">\(H\)</span> are universal graphs on the natural numbers. Define a sequence of finite subsets <span class="math inline">\(A_1,A_2,\dots\)</span> of <span class="math inline">\(\mathbb{N}\)</span> and functions <span class="math inline">\(f_1,f_2,\dots\)</span>, where</p>
<p><span class="math display">\[
f_n:A_n\to\mathbb{N}
\]</span></p>
<p>for each <span class="math inline">\(n\in\mathbb{N}\)</span> recursively as follows.</p>
<p>Define <span class="math inline">\(A_1=\lbrace 1\rbrace\)</span> and <span class="math inline">\(f_1(1)=1\)</span>. Note that <span class="math inline">\(f_1\)</span> is injective and trivially satisfies the relations <span class="math inline">\(\lbrace 1\rbrace \subseteq A_1\)</span> and <span class="math inline">\(\lbrace 1\rbrace \subseteq f_1(A_1)\)</span>.</p>
<p>Given a number <span class="math inline">\(n\in\mathbb{N}\)</span>, suppose we have defined <span class="math inline">\(A_n\)</span> and <span class="math inline">\(f_n\)</span> such that <span class="math inline">\(f_n\)</span> is injective and satisfies the properties that</p>
<p><span class="math display">\[
\lbrace 1,2,\dots n\rbrace \subseteq A_n \quad\text{and}\quad \lbrace 1,2,\dots n\rbrace \subseteq f_n(A_n).
\]</span></p>
<p>Consider two cases concerning whether <span class="math inline">\(n+1\in f_n(A_n)\)</span>. - Suppose that <span class="math inline">\(n+1\in f_n(A_n)\)</span>. In this case, let <span class="math inline">\(a\in A_n\)</span> such that <span class="math inline">\(f_n(a)=n+1\)</span>. - Conversely, if <span class="math inline">\(n+1\notin f_n(A_n)\)</span>, by universality of <span class="math inline">\(G\)</span>, there exists a choice of vertex <span class="math inline">\(a\in\mathbb{N}\setminus A_n\)</span> such that, for all <span class="math inline">\(s\in A_n\)</span>, the equivalence</p>
<p><span class="math display">\[
\lbrace  a,s\rbrace \in \operatorname{Edges}(G) \iff \lbrace n+1,f_n(s)\rbrace \in\operatorname{Edges}(H)
\]</span></p>
<p>holds.</p>
<p>Similarly, consider the following cases: - If <span class="math inline">\(n+1\in A_n\)</span>, let <span class="math inline">\(b=f_n(n+1)\)</span>. - If <span class="math inline">\(a=n+1\)</span>, where <span class="math inline">\(a\)</span> is the number chosen above, also let <span class="math inline">\(b=n+1\)</span>. - Otherwise, analogous to the step above, by universality of <span class="math inline">\(H\)</span> there exists a choice of vertex <span class="math inline">\(b\in\mathbb{N}\setminus f_n(A_n)\)</span> such that, for all <span class="math inline">\(s\in A_n\)</span>, the equivalence</p>
<p><span class="math display">\[
\lbrace n+1,s\rbrace \in \operatorname{Edges}(G) \iff \lbrace b,f_n(s)\rbrace \in\operatorname{Edges}(H)
\]</span></p>
<p>holds.</p>
<p>Regardless of which of the cases above were used, define</p>
<p><span class="math display">\[
A_{n+1} = A_n\cup\lbrace n+1, a\rbrace
\]</span></p>
<p>and <span class="math inline">\(f_{n+1}:A_{n+1}\to\mathbb{N}\)</span> as <span class="math inline">\(f_{n+1}(s)= f_n(s)\)</span> for every $sA_nn+1,a$, and</p>
<p><span class="math display">\[
f_{n+1}(n+1) = b \quad\text{and}\quad f_{n+1}(a) = n+1.
\]</span></p>
<p>It is evident that <span class="math inline">\(f_{n+1}\)</span> is injective, and that <span class="math inline">\(\lbrace 1,\dots,n+1\rbrace \subseteq A_{n+1}\cap f_{n+1}(A_{n+1})\)</span>.</p>
<p>With the subsets <span class="math inline">\(A_1,A_2,\dots\)</span> and functions <span class="math inline">\(f_1,f_2,\dots\)</span> defined this way, note that we have the chain of inclusions</p>
<p><span class="math display">\[
A_1\subseteq A_2\subseteq \cdots.
\]</span></p>
<p>Moreover, for every <span class="math inline">\(n\in\mathbb{N}\)</span>, it holds that <span class="math inline">\(f_{n+1}\|_{A_n} = f_n\)</span> and for pair of distinct numbers <span class="math inline">\(a,b\in A_n\)</span> we have the equivalence</p>
<p><span class="math display">\[
\lbrace a,b\rbrace \in \operatorname{Edges}(G) \iff \lbrace f_n(a),f_n(b)\rbrace \in \operatorname{Edges}(H).
\]</span></p>
<p>We may now define the desired graph isomorphism <span class="math inline">\(f:\mathbb{N}\to\mathbb{N}\)</span> as</p>
<p><span class="math display">\[
f(n) = f_n(n)
\]</span></p>
<p>for every <span class="math inline">\(n\in\mathbb{N}\)</span>. <span class="math inline">\(\square\)</span></p>
</section>
<section id="random-infinite-graphs-are-almost-always-the-same" class="level2">
<h2 class="anchored" data-anchor-id="random-infinite-graphs-are-almost-always-the-same">Random infinite graphs are almost always the same</h2>
<p>We now get to the main point of this post: random infinite graphs.</p>
<p>We can randomly construct a graph on a set of vertices as follows. Given a set of vertices <span class="math inline">\(V\)</span>, for each pair of distinct vertices in <span class="math inline">\(V\)</span>, a biased coin is flipped with a probability of <span class="math inline">\(p\)</span> of landing on heads. If the coin lands on heads, an edge is created between those two vertices. This process is repeated for all pairs of distinct vertices in <span class="math inline">\(V\)</span>, and the events of whether an edge is created between two vertices are independent of one another. Essentially, the graph is constructed by randomly deciding, with a certain probability, whether or not to add an edge between each pair of distinct vertices.</p>
<p>This process induces a probability measure on the set <span class="math inline">\(\operatorname{Graph}(V)\)</span> of all graphs having vertex set <span class="math inline">\(V\)</span>, which is</p>
<p><span class="math display">\[
\operatorname{Graph}(V) = \mathcal{P}\left(\binom{V}{2}\right),
\]</span></p>
<p>where <span class="math inline">\(\mathcal{P}(S)\)</span> denotes the power set of a set <span class="math inline">\(S\)</span>. For each pair of distinct elements <span class="math inline">\(a,b\in V\)</span>, define</p>
<p><span class="math display">\[
A_{\lbrace a,b\rbrace } = \big\lbrace G\in \operatorname{Graph}(V)\,:\, \lbrace a,b\rbrace \in\operatorname{Edges}(G)\big\rbrace
\]</span></p>
<p>to be the event that the randomly generated graph contains the edge connecting <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> such that</p>
<p><span class="math display">\[
\operatorname{Pr}\big(\lbrace a,b\rbrace \in\operatorname{Edges}(G)\big) = \operatorname{Pr}(A_{\lbrace a,b\rbrace }) = p,
\]</span></p>
<p>and these events are all independent of each other.</p>
<p>We now turn our attention to infinite graphs. It turns out that random graphs constructed this way are almost always all isomorphic to each other. This is because a graph constructed this way is almost always universal!</p>
<blockquote class="blockquote">
<p><strong>Theorem.</strong> Let <span class="math inline">\(G\)</span> be a random graph with <span class="math inline">\(\operatorname{Vertices}(G)=\mathbb{N}\)</span> constructed as above. The ranom graph <span class="math inline">\(G\)</span> is universal with probability <span class="math inline">\(1\)</span>.</p>
</blockquote>
<p><em>Proof.</em> We prove that the set of graphs that are not universal is a set of measure zero. Given disjoint finite sets <span class="math inline">\(S,T\subseteq\mathbb{N}\)</span> and a number <span class="math inline">\(a\in\mathbb{N}\setminus (S\cup T)\)</span>, let <span class="math inline">\(A(S,T,a)\)</span> denote the event that in the graph <span class="math inline">\(G\)</span>, the vertex <span class="math inline">\(a\)</span> is adjacent to every vertex in <span class="math inline">\(S\)</span> and not adjacent to every vertex in <span class="math inline">\(T\)</span>. That is,</p>
<p><span class="math display">\[
A(S,T,a) = \Bigg(\bigcup_{s\in S} A_{\lbrace a,t\rbrace }\Bigg)\cup\Bigg(\bigcup_{t\in T} (A_{\lbrace a,t\rbrace })^c\Bigg).
\]</span></p>
<p>Note that the probability of this event is given by</p>
<p><span class="math display">\[
\operatorname{Pr}\big(A(S,T,a)\big) = p^{|S|}(1-p)^{|T|}.
\]</span></p>
<p>Given finite disjoint subsets <span class="math inline">\(S,T\subseteq\mathbb{N}\)</span> that are not both nonempty, note that the events <span class="math inline">\(A(S,T,a)\)</span> and <span class="math inline">\(A(S,T,b)\)</span> are independent from one another for each choice of <span class="math inline">\(a,b\in\mathbb{N}\setminus (S\cup T)\)</span> and thus</p>
<p><span class="math display">\[
\begin{align*}
\operatorname{Pr}\Bigg(\bigcap_{a\in\mathbb{N}\setminus(S\cup T)}A(S,T,a)^c\Bigg)
&amp;= \prod_{a\in\mathbb{N}\setminus(S\cup T)}\left(1-p^{|S|}(1-p)^{|T|}\right)\\
&amp;=\lim_{k\to\infty}\left(1-p^{|S|}(1-p)^{|T|}\right)^k\\
&amp; =0,
\end{align*}
\]</span></p>
<p>as $0 p<sup>{S}(1-p)</sup>{T} $. Now, the event that the random graph is <em>not</em> universal is</p>
<p><span class="math display">\[
\bigcup_{n\in\mathbb{N}}\bigcup_{S\in\binom{\mathbb{N}}{k}}\bigcup_{n\in\mathbb{N}}\bigcup_{T\in\binom{\mathbb{N}\setminus S}{k}}\Bigg(\bigcap_{a\in\mathbb{N}\setminus(S\cup T)}A(S,T,a)^c\Bigg),
\]</span></p>
<p>which is a countable union of a measure-zero sets, and thus also has zero measure. <span class="math inline">\(\square\)</span></p>
<p>We conclude that there is a graph <span class="math inline">\(H\)</span> on <span class="math inline">\(\mathbb{N}\)</span> such that a randomly generated graph <span class="math inline">\(G\)</span> is almost always isomorphic to <span class="math inline">\(H\)</span>.</p>
<blockquote class="blockquote">
<p><strong>Corollary.</strong> With probability one, random graphs on <span class="math inline">\(\mathbb{N}\)</span> are all isomorphic to one another.</p>
</blockquote>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>